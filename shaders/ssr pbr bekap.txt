#version 300 es
precision highp float;

in vec2 vUV;
out vec4 fragColor;

/* ---------- G-buffer & uniforms ---------- */
uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D gAlbedo;
uniform sampler2D gMaterial;
uniform sampler2D tBentNormalAO;
uniform samplerCube uEnvMap;
uniform sampler2D uBRDFLUT;
uniform sampler2D uShadowMap;
uniform sampler2D uSceneColor;

uniform mat4  uView, uLightVP, uProjection;
uniform vec3  uCameraPos;
uniform vec3  uSunDir,  uSunColor;
uniform float uSunIntensity;
uniform float uBiasBase, uBiasSlope;
uniform float uLightSize;
uniform float uCubeMaxMip;
uniform vec2  uShadowMapSize;

/* ---------- tuning (edit if you want) ---------- */
const int   SSR_MAX_STEPS    = 96;
const int   SSR_BINARY_ITERS = 6;
const float SSR_STEP_MIN     = 0.015;
const float SSR_STEP_MAX     = 0.08;
const float SSR_THICKNESS    = 0.06;
const float SSR_JITTER       = 0.03;
const int   SSR_JITTER_SAMPLES = 2;
const float SSR_BLUR_RADIUS  = 1.2;
const float SSR_EDGE_MARGIN  = 0.03;
const float SSR_DEPTH_SCALE  = 0.2;

/* ---------- helpers ---------- */
float hash12(vec2 p){ return fract(sin(dot(p, vec2(27.167,91.453)))*43758.5453); }

vec3 fresnelSchlick(float c, vec3 F0){ return F0 + (1.0-F0)*exp2(-5.2 * c); }
vec3 fresnelSchlickRoughness(float c, vec3 F0, float r){
    return F0 + (max(vec3(1.0-r),F0)-F0)*exp2(-5.2 * c);
}
float geometrySmith(float Nv,float Nl,float r){
    float k = pow(r+1.0,2.0)/8.0;
    float Gl = Nl/(Nl*(1.0-k)+k);
    float Gv = Nv/(Nv*(1.0-k)+k);
    return Gl*Gv;
}
float distributionGGX(vec3 N,vec3 H,float r){
    float a2 = pow(r*r,2.0);
    float NdotH = max(dot(N,H),0.0);
    float d = (NdotH*NdotH)*(a2-1.0)+1.0;
    return a2/(3.141592*d*d);
}

/* ---------- shadow PCF ---------- */
float getShadowView(vec3 Pv, vec3 Nw){
    vec3 L = normalize(uSunDir);
    float cosT = max(dot(Nw,L),0.0);
    float bias = max(uBiasBase, uBiasSlope*(1.0-cosT));

    vec4 lp  = uLightVP * inverse(uView) * vec4(Pv,1.0);
    vec3 uvw = lp.xyz/lp.w*0.5+0.5;
    if (uvw.x<0.0||uvw.x>1.0||uvw.y<0.0||uvw.y>1.0||uvw.z>1.0) return 1.0;

    const vec2 disk[4]=vec2[](
        vec2(0.5,0.5), vec2(-0.5,0.5),
        vec2(0.5,-0.5), vec2(-0.5,-0.5));

    vec2 texel  = 1.0/uShadowMapSize;
    float sh=0.0;
    for(int i=0;i<4;i++){
        vec2 offs = disk[i]*texel;
        float d   = texture(uShadowMap, uvw.xy+offs).r;
        sh += step(uvw.z-bias, d);
    }
    return sh/4.0;
}

/* ---------- utility ---------- */
vec3 samplePos(vec2 uv){ return texture(gPosition, uv).rgb; }
vec3 sampleNormal(vec2 uv){ return normalize(texture(gNormal, uv).rgb); }

/* ---------- bilateral blur ---------- */
vec3 ssrBilateralBlur(vec2 centerUV, vec3 baseColor, float baseDepth, vec3 baseNormal) {
    ivec2 ts = textureSize(uSceneColor, 0);
    vec2 texel = 1.0 / vec2(ts);
    vec3 accum = vec3(0.0);
    float wsum = 0.0;
    for(int y=-1;y<=1;y++){
        for(int x=-1;x<=1;x++){
            vec2 uv = centerUV + vec2(x,y) * texel * SSR_BLUR_RADIUS;
            vec3 col = texture(uSceneColor, uv).rgb;
            vec3 p = samplePos(uv);
            if(length(p) < 1e-5) continue;
            float d = abs(p.z - baseDepth);
            float dn = max(0.0, dot(baseNormal, sampleNormal(uv)));
            float wd = exp(-d * 40.0);
            float wn = pow(dn, 6.0);
            float w = wd * wn;
            accum += col * w;
            wsum += w;
        }
    }
    if (wsum <= 0.0) return baseColor;
    return accum / wsum;
}

/* ========================================================= */
void main(){
    vec3 fragPosV = texture(gPosition, vUV).rgb;
    if(length(fragPosV)<1e-5) discard;

    vec3 normalV   = normalize(texture(gNormal,  vUV).rgb);
    vec3 baseColor = texture(gAlbedo, vUV).rgb;
    vec4 m         = texture(gMaterial, vUV);
    float rough    = clamp(m.r,0.04,1.0);
    float metal    = clamp(m.g,0.0,1.0);

    vec4 bnAO      = texture(tBentNormalAO, vUV);
    vec3 bentN     = normalize(bnAO.rgb*2.0-1.0);
    float ao       = bnAO.a;

    mat3  V3 = mat3(uView);
    mat3  invV3 = transpose(V3);

    vec3 N  = normalize(normalV);
    vec3 Nw = normalize(invV3*N);
    vec3 V  = normalize(-fragPosV);
    vec3 Lv = normalize(V3*normalize(uSunDir));
    vec3 H  = normalize(V+Lv);
    vec3 Rv = reflect(-V,N);
    vec3 Rw = invV3*Rv;

    /* --- direct lighting --- */
    float shadow = getShadowView(fragPosV,Nw);
    float NdotL  = max(dot(N,Lv),0.0);
    float NdotV  = max(dot(N,V ),0.0);

    vec3  F0 = mix(vec3(0.04), baseColor, metal);
    float D  = distributionGGX(N,H,rough);
    float G  = geometrySmith(NdotV,NdotL,rough);
    vec3  F  = fresnelSchlickRoughness(max(dot(H,V),0.0),F0,rough);
    vec3  specBRDF = (D*G*F)/(4.0*NdotV*NdotL+0.001);

    vec3 kd   = (1.0-F)*(1.0-metal);
    vec3 diff = kd*baseColor/3.141592;
    vec3 radiance = uSunColor*uSunIntensity;
    vec3 direct = (diff+specBRDF)*radiance*NdotL*(shadow*1.5);

    /* --- IBL --- */
    vec3 envDiff = textureLod(uEnvMap, normalize(invV3*bentN), uCubeMaxMip*0.98).rgb;
    float mip    = clamp(rough*uCubeMaxMip,0.0,uCubeMaxMip);
    vec3 envSpec = textureLod(uEnvMap, normalize(Rw), mip).rgb;
    vec2 brdf    = texture(uBRDFLUT, vec2(NdotV,rough)).rg;

    /* ---------- SSR: optimized ---------- */
    vec3 reflFinal = envSpec;

    if (rough < 0.9) {
        vec3 accumColor = vec3(0.0);
        float accumWeight = 0.0;

        vec3 R = normalize(reflect(-V, N));

        // adaptive number of steps/samples
        int maxSteps = int(mix(float(SSR_MAX_STEPS), float(SSR_MAX_STEPS) * 0.4, rough));
        int jitterSamples = int(mix(float(SSR_JITTER_SAMPLES), 1.0, rough));

        vec3 up = abs(N.y) > 0.999 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,0.0);
        vec3 T = normalize(cross(up, N));
        vec3 B = normalize(cross(N, T));

        for (int s = 0; s < jitterSamples; s++) {
            float rnd = hash12(vUV + float(s)*0.37);
            float a = (rnd - 0.5) * 2.0 * SSR_JITTER;
            float b = (fract(rnd * 7.7) - 0.5) * 2.0 * SSR_JITTER;
            vec3 jitterDir = normalize(R + T * a + B * b);

            float viewAngle = max(dot(N, V), 0.05);
            float stepSize = mix(SSR_STEP_MIN, SSR_STEP_MAX, rough) * mix(0.3, 1.0, pow(viewAngle, 0.8));

            vec3 ray = fragPosV + N * max(0.01, SSR_THICKNESS * 0.5);
            bool hit = false;
            vec2 hitUV = vUV;
            float bestDiff = 1e6;
            float traveled = 0.0;

            for (int i = 0; i < maxSteps; i++) {
                ray += jitterDir * stepSize;
                traveled += stepSize;

                vec4 clip = uProjection * vec4(ray, 1.0);
                if (clip.w <= 0.0) break;
                vec3 ndc = clip.xyz / clip.w;
                if (abs(ndc.x) > 1.0 || abs(ndc.y) > 1.0) break;
                vec2 uv = ndc.xy * 0.5 + 0.5;

                vec3 scenePosV = samplePos(uv);
                if (length(scenePosV) < 1e-5) continue;

                float rayDepth = -ray.z;
                float sceneDepth = -scenePosV.z;
                float diffZ = sceneDepth - rayDepth;

                // depth-based early exit
                if (diffZ < -SSR_THICKNESS * 0.5) break;

                float maxAccept = stepSize * 3.0 * SSR_DEPTH_SCALE + traveled * 0.02;
                if (diffZ > -SSR_THICKNESS * 0.5 && diffZ < maxAccept) {
                    vec3 hitN = sampleNormal(uv);
                    float facing = dot(hitN, -jitterDir);
                    if (facing > 0.15) {
                        hit = true;
                        hitUV = uv;
                        bestDiff = diffZ;
                        break;
                    }
                }
            }

            if (hit) {
                vec3 rayA = ray - jitterDir * stepSize;
                vec3 rayB = ray;
                for (int j = 0; j < SSR_BINARY_ITERS; j++) {
                    vec3 mid = (rayA + rayB) * 0.5;
                    vec4 clip = uProjection * vec4(mid, 1.0);
                    if (clip.w <= 0.0) break;
                    vec3 ndc = clip.xyz / clip.w;
                    vec2 uv = ndc.xy * 0.5 + 0.5;
                    vec3 sp = samplePos(uv);
                    if (length(sp) < 1e-5) { rayA = mid; continue; }
                    float rd = -mid.z;
                    float sd = -sp.z;
                    float d = sd - rd;
                    if (d > 0.0) rayB = mid; else rayA = mid;
                }

                vec4 clip = uProjection * vec4(rayB, 1.0);
                vec3 ndc = clip.xyz / clip.w;
                hitUV = ndc.xy * 0.5 + 0.5;

                vec3 ssrColor = textureLod(uSceneColor, hitUV, rough * 2.0).rgb;
                vec3 hitP = samplePos(hitUV);
                vec3 hitN = sampleNormal(hitUV);
                if (length(hitP) > 1e-5)
                    ssrColor = ssrBilateralBlur(hitUV, ssrColor, hitP.z, hitN);

                float edgeFade = 1.0;
                edgeFade *= smoothstep(0.0, SSR_EDGE_MARGIN, hitUV.x);
                edgeFade *= smoothstep(0.0, SSR_EDGE_MARGIN, hitUV.y);
                edgeFade *= smoothstep(1.0, 1.0 - SSR_EDGE_MARGIN, hitUV.x);
                edgeFade *= smoothstep(1.0, 1.0 - SSR_EDGE_MARGIN, hitUV.y);

                float angleFade = pow(max(dot(N, V), 0.0), 3.0);
                float roughFade = 1.0 - smoothstep(0.0, 0.9, rough);
                float depthFade = 1.0 - smoothstep(0.0, 0.4 * SSR_DEPTH_SCALE, bestDiff);

                float blend = clamp(edgeFade * roughFade * angleFade * depthFade, 0.0, 1.0);
                float fresnelWeight = clamp(pow(1.0 - max(dot(R, V), 0.0), 2.2), 0.0, 1.0);

                float w = blend * (0.4 + 0.6 * fresnelWeight);
                accumColor += ssrColor * w;
                accumWeight += w;
            }
        }

        if (accumWeight > 0.0) {
            vec3 avgSSR = accumColor / accumWeight;
            float specMix = clamp(1.0 - rough * 1.1, 0.0, 1.0);
            vec3 F_ibl = fresnelSchlickRoughness(NdotV, F0, rough);
            reflFinal = mix(envSpec, avgSSR, specMix * (1.0 - rough*0.5));
            reflFinal = mix(reflFinal, avgSSR, F_ibl.x * 0.5);
        }
    }

    /* --- IBL composition --- */
    vec3 F_ibl   = fresnelSchlickRoughness(NdotV, F0, rough);
    vec3 diffIBL = envDiff * baseColor * (1.0 - metal);
    vec3 specIBL = reflFinal * (F_ibl * brdf.x + brdf.y);

    vec3 color = direct + diffIBL * ao + specIBL * ao;
    fragColor = vec4(vec3(color), 1.0);
}
