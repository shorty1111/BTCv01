#version 300 es
precision highp float;

in vec2 vUV;
out vec4 fragColor;

uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D gMaterial;
uniform sampler2D uSceneColor;
uniform mat4 uProjection;
uniform vec2 uResolution;
uniform samplerCube uEnvMap;
uniform float uCubeMaxMip;

// === GI CONTROL ===
const float GI_STRENGTH = 1.0;
const float GI_ENV_MIX = 0.25;
const float GI_DISTANCE = 1.5;
const float GI_METAL_BOOST = 1.2;
const float GI_BASE_BLEND = 0.6;
const int GI_SAMPLES = 6;
const float ENV_LOD_BIAS = 0.5;
const float GI_FALLOFF = 0.6;

// === SSR CONTROL ===
const float BASE_STEP = 0.08;
const float THICKNESS = 0.85;
const int MAX_STEPS = 45;
const float MAX_DIST = 70.0;

vec3 getPos(vec2 uv) { return texture(gPosition, uv).rgb; }
vec3 getNormal(vec2 uv) { return normalize(texture(gNormal, uv).rgb); }

vec2 projectToUV(vec3 pV) {
    vec4 clip = uProjection * vec4(pV, 1.0);
    vec2 ndc = clip.xy / clip.w;
    vec2 uv = ndc * 0.5 + 0.5;
    return clamp(uv, 0.002, 0.998);
}

vec2 getStableHash(vec2 uv) {
    vec2 cell = floor(uv * vec2(4000.0));
    float h1 = fract(sin(dot(cell, vec2(12.9898,78.233))) * 43758.5453);
    float h2 = fract(sin(dot(cell + 13.37, vec2(41.23,95.78))) * 24634.6345);
    return vec2(h1, h2);
}

vec3 sampleHemisphere(vec3 normal, vec2 random) {
    float cosTheta = sqrt(random.x);
    float sinTheta = sqrt(1.0 - random.x);
    float phi = random.y * 6.2831853;

    vec3 w = normal;
    vec3 u = normalize(cross(w, abs(w.x) > 0.1 ? vec3(0,1,0) : vec3(1,0,0)));
    vec3 v = cross(w, u);

    return normalize(u * cos(phi) * sinTheta + v * sin(phi) * sinTheta + w * cosTheta);
}

vec3 getAmbientGI(vec3 worldPos, vec3 normal, vec2 seed) {
    vec3 giAccum = vec3(0.0);

    for(int i = 0; i < GI_SAMPLES; i++) {
        vec2 r = fract(seed + vec2(float(i) * 0.617, float(i) * 0.755));
        vec3 sampleDir = sampleHemisphere(normal, r);

        vec3 samplePos = worldPos + sampleDir * GI_DISTANCE;
        vec2 sampleUV = projectToUV(samplePos);

        vec3 sampleColor;
        float weight = 1.0;

        if(sampleUV.x > 0.0 && sampleUV.x < 1.0 && sampleUV.y > 0.0 && sampleUV.y < 1.0) {
            vec3 sceneColor = pow(texture(uSceneColor, sampleUV).rgb, vec3(2.2));
            vec3 envColor = textureLod(uEnvMap, sampleDir, ENV_LOD_BIAS).rgb;
            float dist = length(samplePos - worldPos);
            float envMix = smoothstep(0.5, 1.0, dist);
            sampleColor = mix(sceneColor, envColor, envMix * GI_ENV_MIX);
        } else {
            float envLod = ENV_LOD_BIAS + dot(sampleDir, normal);
            sampleColor = textureLod(uEnvMap, sampleDir, envLod).rgb;
            weight = 0.8;
        }

        float dist = length(samplePos - worldPos);
        float falloff = 1.0 / (1.0 + dist * GI_FALLOFF);
        giAccum += sampleColor * falloff * weight;
    }

    giAccum /= float(GI_SAMPLES);
    return pow(giAccum, vec3(1.0 / 2.2)); // gamma correction back
}

void main() {
    vec3 posV = getPos(vUV);
    if (posV.z > -0.1) {
        fragColor = texture(uSceneColor, vUV);
        return;
    }

    vec3 N = getNormal(vUV);
    vec3 V = normalize(-posV);
    float NdotV = max(dot(N, V), 0.0);
    vec3 R = reflect(-V, N);

    vec2 material = texture(gMaterial, vUV).rg;
    float roughness = material.r;
    float metallic = material.g;

    if (NdotV < 0.1 || roughness > 0.98) {
        fragColor = texture(uSceneColor, vUV);
        return;
    }

    float spread = roughness * roughness * 0.8;
    vec2 hash = getStableHash(vUV);
    float angle = hash.x * 6.2831853;
    float amp = (hash.y - 0.5) * 2.0 * spread * 0.5;

    vec3 up = abs(R.z) < 0.999 ? vec3(0.0,0.0,1.0) : vec3(1.0,0.0,0.0);
    vec3 T = normalize(cross(up, R));
    vec3 B = cross(R, T);
    R = normalize(R + amp * (T * cos(angle) + B * sin(angle)));

    float adaptStep = mix(0.03, BASE_STEP, clamp(abs(R.z), 0.0, 1.0));
    vec3 ray = posV + N * mix(0.02, 0.1, 1.0 - NdotV);
    vec3 stepV = R * adaptStep;
    int steps = int(mix(10.0, float(MAX_STEPS), 1.0 - roughness));

    vec3 hitColor = vec3(0.0);
    vec2 hitUV = vec2(0.0);
    float hit = 0.0;
    vec3 lastRayPos = ray;
    int i;

    for (i = 0; i < steps; i++) {
        lastRayPos = ray;
        ray += stepV;

        if (ray.z < -MAX_DIST || ray.z > -0.1) break;
        vec2 uv = projectToUV(ray);
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) break;

        float mip = float(i) / float(MAX_STEPS) * 5.0;
        vec3 sceneP = textureLod(gPosition, uv, mip).rgb;
        float dz = ray.z - sceneP.z;
        if (abs(dz) > THICKNESS) continue;

        if (dz < 0.0 && dz > -THICKNESS) {
            if (sceneP.z == 0.0) break;
            for (int j = 0; j < 2; j++) {
                vec3 midRay = (lastRayPos + ray) * 0.5;
                vec2 midUV = projectToUV(midRay);
                if (midUV.x < 0.0 || midUV.x > 1.0 || midUV.y < 0.0 || midUV.y > 1.0) break;
                vec3 midScene = getPos(midUV);
                if (midRay.z > midScene.z) lastRayPos = midRay;
                else { ray = midRay; uv = midUV; }
            }

            float lod = roughness * 5.0;
            hitColor = textureLod(uSceneColor, uv, lod).rgb;
            hitUV = uv;
            hit = 1.0;
            break;
        }
    }

    if (hit > 0.5 && roughness > 0.05) {
        vec2 texel = 1.0 / uResolution;
        float radius = mix(0.0, 4.0, roughness);
        vec3 sum = vec3(0.0);
        float wsum = 0.0;

        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                vec2 offs = vec2(x, y) * texel * radius;
                float w = 1.0 / (1.0 + dot(offs, offs) * 100.0);
                sum += textureLod(uSceneColor, hitUV + offs, roughness * 5.0).rgb * w;
                wsum += w;
            }
        }
        vec3 blurred = sum / max(wsum, 1e-4);
        hitColor = mix(hitColor, blurred, roughness * 1.2);
    }

    vec3 base = texture(uSceneColor, vUV).rgb;
    vec2 giSeed = getStableHash(vUV * 1.7);
    vec3 ambientGI = getAmbientGI(posV, N, giSeed);

    float giStrength = GI_STRENGTH * mix(1.0, GI_METAL_BOOST, metallic);
    vec3 enhancedBase = mix(base, base * (1.0 + ambientGI * giStrength * 0.5), GI_BASE_BLEND);

    float gloss = 1.0 - roughness;
    float fresnel = pow(1.0 - NdotV, 5.0);
    float F0 = mix(0.04, 1.0, metallic);
    float F = F0 + (1.0 - F0) * fresnel;

    vec2 screenCenter = hitUV * 2.0 - 1.0;
    float screenFade = 1.0 - pow(max(abs(screenCenter.x), abs(screenCenter.y)), 1.5);
    float metallicBoost = mix(1.0, 1.5, metallic);

    float conf = 1.0 - float(i) / float(MAX_STEPS);
    float blend = hit * F * gloss * screenFade * metallicBoost * conf;
    float edgeFade = smoothstep(0.0, 0.1, min(min(vUV.x, vUV.y), min(1.0 - vUV.x, 1.0 - vUV.y)));
    blend *= edgeFade;

    fragColor = vec4(mix(enhancedBase, hitColor, blend), 1.0);
}
